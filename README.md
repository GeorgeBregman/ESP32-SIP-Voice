# ESP32-SIP-Voice
ESP32-based SIP VoIP client (ESP-IDF + FreeRTOS). Tasks, queues, and core SIP call flow logic. Uses G.711 µ-law and I2S codec (e.g., ES8388).

Assumptions:
ESP-IDF v4.4 or later is used.
An external I2S audio codec like ES8388 is targeted (requiring a specific driver). We'll use placeholder function calls.
G.711 µ-law (PCMU) is the primary codec (Payload Type 0).
Focus is on the core structure and interaction, not exhaustive SIP header parsing or edge-case handling.
Basic NAT traversal (STUN) is omitted in this initial code structure for clarity but noted where it would integrate.
Error handling is present but may need further hardening.

esp32_sip_client/

├── main/

│   ├── main.c                 # App entry point, task creation

│   ├── Kconfig.projbuild      # Project specific config (if needed)

│   ├── component.mk           # Standard component makefile

│   ├── wifi_manager.c

│   ├── wifi_manager.h

│   ├── sip_client.c

│   ├── sip_client.h

│   ├── rtp_handler.c

│   ├── rtp_handler.h

│   ├── audio_pipeline.c

│   ├── audio_pipeline.h

│   ├── g711_codec.c           # Standard G.711 implementation

│   ├── g711_codec.h

│   ├── codec_driver.c         # Placeholder/Specific driver for ES8388 etc.

│   ├── codec_driver.h

│   └── app_config.h           # User configurations (WiFi, SIP creds, Pins)

├── sdkconfig                # Generated by menuconfig

└── CMakeLists.txt           # Project CMake file

Next Steps & Important Considerations:

SIP State Machine: The process_incoming_sip function is extremely basic. A full implementation requires a robust state machine (UAC - User Agent Client, UAS - User Agent Server) covering all transaction states (Trying, Proceeding, Completed, Terminated) and dialog states (Early, Confirmed, Terminated) as defined in RFC 3261. This is the most complex part.

SIP Parsing: The header parsing is minimal. A real client needs to handle multi-line headers, parameters (like tag, branch, rport), URI parsing (user, host, port), etc. Libraries exist for this, but add overhead.

Transaction Matching: Correctly matching responses to requests requires checking Via branch, CSeq number and method, Call-ID, and From/To tags. ACKs need to be routed correctly based on Contact/Record-Route headers.

Digest Authentication: Essential for real-world use. Implement parsing of WWW-Authenticate/Proxy-Authenticate and generation of Authorization/Proxy-Authorization headers using MD5.

Codec Driver: Replace the placeholder codec_driver.c with the actual driver for your chosen hardware (ES8388, WM8978, etc.). Consider using drivers from the ESP-ADF (Audio Development Framework) if suitable.

G.711 Implementation: Find and integrate a standard, correct C implementation for g711_codec.c.

Jitter Buffer: Implement the rtp_jitter_buffer_put and rtp_jitter_buffer_get functions. Start with a simple fixed-delay buffer and potentially move to an adaptive one if needed. Add mutex protection.

I2S Data Format: Ensure the bits_per_sample and channel_format in i2s_init match what your codec expects/provides and that the G.711 encode/decode functions handle the linear PCM format correctly (usually 16-bit signed). The example assumes 16-bit I2S and conversion in encode/decode.

Error Handling: Add more comprehensive error checking and recovery mechanisms (e.g., socket recreation on failure, task restarts).

Memory Management: Monitor heap usage (heap_caps_get_free_size) carefully, especially during calls. Optimize buffer sizes. Consider PSRAM if available and needed.

NAT Traversal (STUN): Integrate a STUN client library to query a STUN server after getting an IP. Use the discovered public IP/port in SIP Via (sent-by) and Contact headers, and potentially the SDP c= line. Handle rport in Via headers.

Testing: Test incrementally against a local SIP server (Asterisk, FreeSWITCH) using softphones and Wireshark for debugging.
